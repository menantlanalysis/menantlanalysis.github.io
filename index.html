
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Middle East & North Africa Nighttime Lights Viewer</title>
   <style>
    /* --- GENERAL STYLES --- */
    body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        margin: 0;
        background-color: #f4f4f9;
        color: #333;
        display: flex;
        flex-direction: column;
        min-height: 100vh;
        padding-bottom: 60px; /* Space for fixed footer */
    }
    #app-container {
        display: flex;
        flex-grow: 1;
        overflow: hidden;
    }
    #menu {
        width: 300px;
        flex-shrink: 0;
        background-color: #fff;
        border-right: 1px solid #ddd;
        padding: 20px;
        overflow-y: auto;
        box-shadow: 2px 0 5px rgba(0,0,0,0.05);
    }
    #menu h2 {
        margin-top: 0;
        color: #0056b3;
    }
    #menu .country-name, #menu .muni-item {
        cursor: pointer;
        padding: 8px;
        border-radius: 4px;
        margin-bottom: 5px;
        transition: background-color 0.2s;
        user-select: none;
    }
    #menu .country-name:hover, #menu .muni-item:hover {
        background-color: #e9ecef;
    }
    .country-name::before {
        content: '‚ñ∫ ';
        font-size: 0.8em;
    }
    .country-name.open::before {
        content: '‚ñº ';
    }
    .muni-list {
        list-style-type: none;
        padding-left: 20px;
        border-left: 2px solid #0056b3;
        margin-left: 8px;
        display: none;
    }
    .muni-list.open {
        display: block;
    }
    #content {
        flex-grow: 1;
        padding: 20px;
        overflow-y: auto;
    }
    #video-container, #chart-wrapper, #stats-summary {
        background-color: #fff;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        margin-bottom: 20px;
    }
    /* Style for chart container to prevent collapse */
    #chart-container {
        width: 100%;
        min-height: 500px;
    }
    #video-player {
        width: 100%;
        height: auto;
        max-height: 70vh;
        border-radius: 4px;
        background-color: #000;
    }
    h3 {
        /* border-bottom: 2px solid #0056b3; */ /* This line is removed */
        padding-bottom: 5px;
        margin-top: 0;
    }
    .chart-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-bottom: 2px solid #0056b3; /* Border is now on the container */
        margin-bottom: 15px;
    }   
    .loader, .error-message {
        text-align: center;
        padding: 40px;
        font-size: 1.2em;
        color: #666;
    }
    footer {
        background-color: #333;
        color: #fff;
        text-align: center;
        padding: 15px 20px;
        font-size: 0.9em;
        border-top: 1px solid #444;
        position: fixed;
        bottom: 0;
        left: 0;
        width: 100%;
        z-index: 1000;
        height: auto;
    }
    footer a {
        color: #fff;
        text-decoration: none;
    }
    footer a:hover {
        text-decoration: underline;
    }

    /* --- HEADER & MOBILE NAV STYLES --- */
    #main-header {
        background-color: #0056b3;
        color: white;
        padding: 0 15px;
        display: none; /* Hidden on desktop */
        align-items: center;
        box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        z-index: 1001;
        height: 60px;
        box-sizing: border-box;
    }

    #main-header h1 {
        font-size: 1.1em;
        margin: 0 0 0 15px;
        flex-grow: 1;
    }

    #menu-toggle {
        background: none;
        border: none;
        cursor: pointer;
        padding: 0;
        z-index: 1002;
        width: 40px;
        height: 40px;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
    }

    #menu-toggle span {
        display: block;
        width: 25px;
        height: 3px;
        background-color: white;
        margin: 2.5px 0;
        transition: all 0.3s ease-in-out;
        border-radius: 2px;
    }

    #menu-overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0,0,0,0.5);
        z-index: 999; /* Below menu, above content */
    }

    /* --- MEDIA QUERY FOR MOBILE --- */
    @media (max-width: 768px) {
        body {
            padding-top: 60px; /* Space for new fixed header */
            padding-bottom: 80px; /* More space for footer on mobile */
        }
        
        #main-header {
            display: flex; /* Show the header on mobile */
        }

        #app-container {
            overflow: visible; /* Allow content to scroll normally */
        }

        /* Make the original menu a slide-out panel */
        #menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 300px;
            max-width: 80vw;
            height: 100%;
            z-index: 1000;
            transform: translateX(-100%);
            transition: transform 0.3s ease-in-out;
            box-shadow: 2px 0 10px rgba(0,0,0,0.2);
            border-right: none;
        }

        #menu.open {
            transform: translateX(0);
        }
        
        /* Show overlay when menu is active */
        body.menu-is-open #menu-overlay {
            display: block;
        }
        
        /* Animate the burger icon into an 'X' */
        body.menu-is-open #menu-toggle span:nth-child(1) {
            transform: rotate(45deg) translate(5px, 5px);
        }
        body.menu-is-open #menu-toggle span:nth-child(2) {
            opacity: 0;
        }
        body.menu-is-open #menu-toggle span:nth-child(3) {
            transform: rotate(-45deg) translate(5px, -5px);
        }

        #content {
            width: 100%;
            padding: 15px;
            box-sizing: border-box;
        }

        #video-container, #chart-wrapper, #stats-summary {
            padding: 15px;
        }
    }
    #stats-table {
        width: 100%;
        margin: 0 auto;
        border-collapse: collapse;
        font-size: 1em;
    }

    #stats-table th,
    #stats-table td {
        padding: 12px 15px;
        text-align: left;
        border: 1px solid #e0e0e0; /* Restored visible vertical borders */
    }

    #stats-table th {
        background-color: #f8f8f8; /* Added a light background to header row */
        color: #555;
        font-weight: 600;
        text-transform: uppercase;
        font-size: 0.8em;
        letter-spacing: 0.5px;
    }

    /* Right-align the "Change" header and its data cells */
    #stats-table th:last-child,
    #stats-table td:last-child {
        text-align: right;
    }

    #stats-table td:first-child {
        color: #444;
    }

    #stats-table td:last-child {
        font-weight: 700;
        font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
    }
   </style>
</head>
<body>

    <header id="main-header">
        <button id="menu-toggle" aria-label="Toggle menu">
            <span></span>
            <span></span>
            <span></span>
        </button>
        <h1>Report</h1>
    </header>
    <div id="menu-overlay"></div>

    <div id="app-container">
        <nav id="menu">
            <h2>Navigation üó∫Ô∏è</h2>
            <div id="location-list"><div class="loader">Loading Data...</div></div>
        </nav>
        <main id="content">
            <div id="video-container" style="display:none;">
                <h3 id="video-title">Video</h3>
                <video id="video-player" controls autoplay muted playsinline></video>
            </div>
            <div id="chart-wrapper" style="display:none;">
                <div class="chart-header">
                    <h3>Data Chart üìà</h3>
                    <a id="download-csv-link" class="download-link" style="display:none;" download>Download CSV</a>
                </div>
                <div id="chart-container">
                    <div class="loader">Loading Chart...</div>
                </div>
            </div>
            <div id="stats-summary" style="display:none;">
                <h3>Summary (LOESS) üìä</h3>
                <table id="stats-table">
                    <thead>
                        <tr>
                            <th>Metric</th>
                            <th>Change</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Year-over-Year</td>
                            <td id="yoy-change">--</td>
                        </tr>
                        <tr>
                            <td>Year-to-Date</td>
                            <td id="ytd-change">--</td>
                        </tr>
                        <tr>
                            <td>Quarter-to-Date</td>
                            <td id="qtd-change">--</td>
                        </tr>
                    </tbody>
                </table>
                <div id="stats-map" style="display:none;">
                </div>
            </div>
        </main>
    </div>
    <footer id="main-footer"></footer>

    <script src="https://cdn.plot.ly/plotly-3.0.1.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/science@1.9.3/science.v1.min.js"></script>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const API_BASE_URL = "";

            const menuToggle = document.getElementById('menu-toggle');
            const menu = document.getElementById('menu');
            const menuOverlay = document.getElementById('menu-overlay');
            const body = document.body;
            const mainHeader = document.getElementById('main-header');

            const locationList = document.getElementById('location-list');
            const videoContainer = document.getElementById('video-container');
            const videoTitle = document.getElementById('video-title');
            const videoPlayer = document.getElementById('video-player');
            const chartWrapper = document.getElementById('chart-wrapper');
            const chartContainer = document.getElementById('chart-container');
            const mainFooter = document.getElementById('main-footer');
            const downloadCsvLink = document.getElementById('download-csv-link');
            const statsSummary = document.getElementById('stats-summary');
            const loess_bandwidth = 0.25;
            
            let websiteData = {};

            function toggleMenu() {
                body.classList.toggle('menu-is-open');
                menu.classList.toggle('open');
            }
            menuToggle.addEventListener('click', toggleMenu);
            menuOverlay.addEventListener('click', toggleMenu);

            function showChartLoader() {
                chartContainer.innerHTML = `<div class="loader">Loading Chart...</div>`;
                statsSummary.style.display = 'none';
            }

            function calculateAndDisplayStats(dates, loessValues) {
                const statsContainer = document.getElementById('stats-summary');
                const yoyCell = document.getElementById('yoy-change');
                const ytdCell = document.getElementById('ytd-change');
                const qtdCell = document.getElementById('qtd-change');

                const smoothedData = dates.map((date, i) => ({
                    date: new Date(date),
                    value: loessValues[i]
                })).sort((a, b) => a.date - b.date);

                if (smoothedData.length < 2) {
                    statsContainer.style.display = 'none';
                    return;
                }

                const lastPoint = smoothedData[smoothedData.length - 1];
                const lastDate = lastPoint.date;

                const findClosestPoint = (targetDate) => {
                    return smoothedData.reduce((prev, curr) => {
                        return (Math.abs(curr.date - targetDate) < Math.abs(prev.date - targetDate) ? curr : prev);
                    });
                };
                
                const calculateChange = (startPoint, endPoint) => {
                    if (!startPoint || !endPoint || startPoint.value === 0 || startPoint.date >= endPoint.date) {
                        return 'N/A';
                    }
                    const change = ((endPoint.value - startPoint.value) / startPoint.value) * 100;
                    const color = change >= 0 ? 'green' : 'red';
                    const sign = change >= 0 ? '‚ñ≤ ' : '‚ñº ';
                    return `<span style="color: ${color};">${sign}${Math.abs(change).toFixed(2)}%</span>`;
                };

                // YoY Calculation
                const oneYearAgoDate = new Date(lastDate);
                oneYearAgoDate.setFullYear(lastDate.getFullYear() - 1);
                const oneYearAgoPoint = findClosestPoint(oneYearAgoDate);
                yoyCell.innerHTML = calculateChange(oneYearAgoPoint, lastPoint);

                // YTD Calculation
                const startOfYearDate = new Date(lastDate.getFullYear(), 0, 1);
                const ytdStartPoint = findClosestPoint(startOfYearDate);
                ytdCell.innerHTML = calculateChange(ytdStartPoint, lastPoint);

                // QTD Calculation
                const quarter = Math.floor(lastDate.getMonth() / 3);
                const startOfQuarterDate = new Date(lastDate.getFullYear(), quarter * 3, 1);
                const qtdStartPoint = findClosestPoint(startOfQuarterDate);
                qtdCell.innerHTML = calculateChange(qtdStartPoint, lastPoint);

                statsContainer.style.display = 'block';
            }

            function sanitizeName(name) {
                return name.replace(/\//g, "_")
                        .replace(/ /g, "_")
                        .trim()
                        .toLowerCase();
            }

            async function initialize() {
                mainHeader.querySelector('h1').textContent = document.title;
                try {
                    const [configResponse, eventsResponse] = await Promise.all([
                        fetch(API_BASE_URL + 'config.json'),
                        fetch(API_BASE_URL + 'events.json')
                    ]);
                    if (!configResponse.ok || !eventsResponse.ok) {
                       throw new Error('Network response was not ok.');
                    }
                    const configData = await configResponse.json();
                    const eventsData = await eventsResponse.json();

                    for (const countryKey in eventsData) {
                        if (configData.countries[countryKey]) {
                            configData.countries[countryKey].events = eventsData[countryKey].events || [];
                            if (eventsData[countryKey].municipalities) {
                                for (const muniKey in eventsData[countryKey].municipalities) {
                                    if (configData.countries[countryKey].municipalities[muniKey]) {
                                        configData.countries[countryKey].municipalities[muniKey].events = eventsData[countryKey].municipalities[muniKey].events || [];
                                    }
                                }
                            }
                        }
                    }
                    websiteData = configData;
                    buildNavigation(websiteData);
                    handleUrlOnLoad();
                    updateFooter(websiteData.last_run_date);
                } catch (error) {
                    console.error("Failed to load or process data:", error);
                    locationList.innerHTML = `<div class="error-message">Error: Could not load site data.</div>`;
                }
            }

            function buildNavigation(data) {
                locationList.innerHTML = '';
                for (const countryKey in data.countries) {
                    const country = data.countries[countryKey];
                    const countryDiv = document.createElement('div');
                    const countryNameH3 = document.createElement('h3');
                    countryNameH3.className = 'country-name';
                    countryNameH3.textContent = country.displayName;
                    countryNameH3.dataset.countryKey = countryKey;
                    countryDiv.appendChild(countryNameH3);

                    const muniList = document.createElement('ul');
                    muniList.className = 'muni-list';
                    for (const muniKey in country.municipalities) {
                        const muniItem = document.createElement('li');
                        muniItem.className = 'muni-item';
                        muniItem.textContent = muniKey.replace(/_\(.*\)|_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()).trim();
                        muniItem.dataset.countryKey = countryKey;
                        muniItem.dataset.muniKey = muniKey;
                        muniList.appendChild(muniItem);
                    }
                    countryDiv.appendChild(muniList);
                    locationList.appendChild(countryDiv);
                }
            }
            
            locationList.addEventListener('click', (e) => {
                const target = e.target;
                const { countryKey, muniKey } = target.dataset;

                if (target.classList.contains('country-name')) {
                    target.classList.toggle('open');
                    target.nextElementSibling.classList.toggle('open');
                    displayCountry(countryKey);
                } else if (target.classList.contains('muni-item')) {
                    displayMunicipality(countryKey, muniKey);
                    if (window.innerWidth <= 768 && menu.classList.contains('open')) {
                        toggleMenu();
                    }
                }
            });

            function updateUrl(countryKey, muniKey = null) {
                const viewParam = muniKey ? `${countryKey},${muniKey}` : countryKey;
                const url = new URL(window.location);
                url.searchParams.set('view', viewParam);
                history.pushState({ view: viewParam }, '', url);
            }

            function handleUrlOnLoad() {
                const params = new URLSearchParams(window.location.search);
                const view = params.get('view');
                if (!view) return;

                const [countryKey, muniKey] = view.split(',');
                
                if (websiteData.countries[countryKey]) {
                    const countryHeader = document.querySelector(`.country-name[data-country-key="${countryKey}"]`);
                    if (countryHeader) {
                        countryHeader.classList.add('open');
                        countryHeader.nextElementSibling.classList.add('open');
                    }
                    
                    if (muniKey && websiteData.countries[countryKey].municipalities[muniKey]) {
                        displayMunicipality(countryKey, muniKey, false);
                    } else {
                        displayCountry(countryKey, false);
                    }
                }
            }

            async function getAllMuniData(countryData) {
                const municipalities = Object.entries(countryData.municipalities);
                const promises = municipalities.map(async ([key, muni]) => {
                    if (!muni.csv) return [key, []];
                    try {
                        const response = await fetch(API_BASE_URL + muni.csv);
                        if (!response.ok) throw new Error(`Failed to fetch ${muni.csv}`);
                        const csvText = await response.text();
                        return new Promise((resolve, reject) => {
                            Papa.parse(csvText, {
                                header: true,
                                dynamicTyping: true,
                                skipEmptyLines: true,
                                complete: (results) => {
                                    const data = results.data.filter(d => d.date && d.luminosity !== undefined);
                                    resolve([key, data.map(d => ({ ...d, time: new Date(d.date).getTime() }))]);
                                },
                                error: (err) => reject(new Error(`Parsing error in ${muni.csv}: ${err.message}`))
                            });
                        });
                    } catch (fetchErr) {
                        return [key, []];  // On fetch failure, empty list
                    }
                });

                const entries = await Promise.all(promises);
                return Object.fromEntries(entries);
            }

            async function displayCountry(countryKey, allMuniData, shouldUpdateUrl = true) {
                chartWrapper.style.display = 'block';
                showChartLoader();
                downloadCsvLink.style.display = 'none'; // Hide link while loading

                if (shouldUpdateUrl) {
                    updateUrl(countryKey);
                }
                
                try {
                    const countryData = websiteData.countries[countryKey];

                    videoTitle.textContent = `${countryData.displayName}`;
                    videoPlayer.src = API_BASE_URL + countryData.video;
                    videoContainer.style.display = 'block';

                    
                    const allMuniData = await getAllMuniData(countryData);
                    const allDatesSet = new Set(
                        Object.values(allMuniData)
                            .flat()
                            .map(d => d.date)
                    );
                    const unifiedTimeline = Array.from(allDatesSet).sort().map(date => ({
                        date, time: new Date(date).getTime() 
                    }));

                    const completedMuniData = Object.values(allMuniData)
                        .flatMap(muniData => {
                            if (muniData.length === 0) return [];
                            const sortedData = [...muniData].sort((a, b) => a.time - b.time);
                            return unifiedTimeline.map(({ date, time }) => {
                                const existingPoint = sortedData.find(p => p.time === time);
                                if (existingPoint) return { date, luminosity: existingPoint.luminosity };

                                const prevPoint = [...sortedData].reverse().find(p => p.time < time);
                                const nextPoint = sortedData.find(p => p.time > time);

                                let luminosity;
                                if (prevPoint && nextPoint) {
                                    const timeDiff = nextPoint.time - prevPoint.time;
                                    const valueDiff = nextPoint.luminosity - prevPoint.luminosity;
                                    const timeRatio = (time - prevPoint.time) / timeDiff;
                                    luminosity = prevPoint.luminosity + (valueDiff * timeRatio);
                                } else if (prevPoint) {
                                    luminosity = prevPoint.luminosity;
                                } else if (nextPoint) {
                                    luminosity = nextPoint.luminosity;
                                } else {
                                    luminosity = 0;
                                }

                                return { date, luminosity };
                            });
                        });

                    const aggregatedData = {};
                    completedMuniData.forEach(({ date, luminosity }) => {
                        if (!aggregatedData[date]) aggregatedData[date] = 0;
                        aggregatedData[date] += luminosity;
                    });

                    const finalChartData = Object.entries(aggregatedData).map(([date, luminosity]) => ({ date, luminosity }));

                    if (finalChartData.length === 0) {
                        throw new Error("No data available to plot for this country.");
                    }
                    const csvString = Papa.unparse(finalChartData);
                    const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8;' });
                    const url = URL.createObjectURL(blob);
                    downloadCsvLink.href = url;
                    downloadCsvLink.download = `${countryKey}_aggregated.csv`;
                    downloadCsvLink.style.display = 'inline-block';
                    drawChart(finalChartData, countryData.events || [], [], countryData.displayName);
                    const response = await fetch(API_BASE_URL + countryData.map);
                    if (!response.ok) throw new Error(`Could not fetch ${countryData.map}`);
                    drawMuniMap(allMuniData, await response.json(), "stats-map", "By Region");
                } catch (error) {
                    console.error("Error displaying country aggregate:", error);
                    chartContainer.innerHTML = `<div class="error-message">${error.message}</div>`;
                }
            }

            /**
             * Draws a choropleth map of municipalities, colored by Year-over-Year (YoY) luminosity change.
             *
             * @param {Array<Object>} muniData - Array of municipality data, each object should have:
             * {id: string, name: string, date: string, luminosity: number}.
             * 'id' should correspond to a 'properties.id' or similar in the GeoJSON features.
             * @param {Object} geojsonData - The GeoJSON object for the municipalities (FeatureCollection).
             * @param {string} chartContainerId - The ID of the HTML element where the chart will be drawn.
             * @param {string} title - The title of the map.
             * @param {string} featureIdKey - The key in the GeoJSON properties that matches `muniData[i].id`.
             * For example, if your GeoJSON features have `properties.muni_id`, then
             * this should be 'properties.muni_id'.
             */
            function drawMuniMap(muniData, geojsonData, chartContainerId, title) {
                const mapContainer = document.getElementById(chartContainerId);
                mapContainer.style.display = 'block';
                if (!mapContainer) {
                    console.error(`Map container with ID '${chartContainerId}' not found.`);
                    return;
                }

                const muniYoYChanges = {};
                Object.entries(muniData).forEach(([key, data]) => {
                    const dates = data.map(row => row.date);
                    const values = data.map(row => row.luminosity);

                    const numericDates = dates.map(d => new Date(d).getTime());
                    const loessGenerator = science.stats.loess().bandwidth(loess_bandwidth);
                    const loessValues = loessGenerator(numericDates, values);

                    const smoothedData = dates.map((date, i) => ({
                        date: new Date(date),
                        value: loessValues[i]
                    })).sort((a, b) => a.date - b.date);

                    if (smoothedData.length < 2) {
                        return;
                    }

                    const lastPoint = smoothedData[smoothedData.length - 1];
                    const lastDate = lastPoint.date;

                    const findClosestPoint = (targetDate) => {
                        return smoothedData.reduce((prev, curr) => {
                            return (Math.abs(curr.date - targetDate) < Math.abs(prev.date - targetDate) ? curr : prev);
                        });
                    };

                    const calculateChange = (startPoint, endPoint) => {
                        if (!startPoint || !endPoint || startPoint.value === 0 || startPoint.date >= endPoint.date) {
                            return null;
                        }
                        const change = ((endPoint.value - startPoint.value) / startPoint.value) * 100;
                        return change;
                    };

                    const oneYearAgoDate = new Date(lastDate);
                    oneYearAgoDate.setFullYear(lastDate.getFullYear() - 1);
                    const oneYearAgoPoint = findClosestPoint(oneYearAgoDate);
                    muniYoYChanges[key] = calculateChange(oneYearAgoPoint, lastPoint);
                });

                const locations = [];
                const zValues = [];
                const hoverTexts = [];

                geojsonData.features.forEach(feature => {
                    const muniName = feature.properties['name'];
                    const muniId = sanitizeName(feature.properties['name']);
                    if (muniId !== undefined) {
                        locations.push(muniName);
                        const yoyChange = muniYoYChanges[muniId];

                        if (yoyChange !== null && yoyChange !== undefined) {
                            zValues.push(yoyChange);
                            const color = yoyChange >= 0 ? 'green' : 'red';
                            const sign = yoyChange >= 0 ? '‚ñ≤' : '‚ñº';
                            hoverTexts.push(`${muniName}<br>YoY Change: <span style="color: ${color};">${sign} ${Math.abs(yoyChange).toFixed(2)}%</span>`);
                        } else {
                            zValues.push(null);
                            hoverTexts.push(`${muniName}<br>YoY Change: N/A`);
                        }
                    } else {
                        console.warn(`GeoJSON feature missing 'name' property:`, feature);
                    }
                });

                const maxAbs = Math.max(...zValues.map(v => Math.abs(v) || 0));
                const choroplethTrace = {
                    type: 'choroplethmap',
                    geojson: geojsonData,
                    locations: locations,
                    z: zValues,
                    zmin: -maxAbs,
                    zmax: maxAbs,
                    featureidkey: `properties.name`,
                    colorscale: [
                        [0, 'red'],
                        [0.5, 'white'],
                        [1, 'green']
                    ],
                    autocolorscale: false,
                    reversescale: false,
                    colorbar: {
                        title: 'YoY Luminosity Change (%)',
                        titleside: 'right'
                    },
                    hoverinfo: 'text',
                    hovertext: hoverTexts,
                    marker: {
                        line: {
                            color: 'white',
                            width: 0.8
                        }
                    },
                    name: 'YoY Change'
                };

                // Calculate center
                let minLon = 180, maxLon = -180, minLat = 90, maxLat = -90;
                geojsonData.features.forEach(feature => {
                    if (feature.geometry && feature.geometry.coordinates) {
                        feature.geometry.coordinates.forEach(polygon => {
                            polygon.forEach(coord => {
                                if (Number.isFinite(coord[0]) && Number.isFinite(coord[1])) {
                                    minLon = Math.min(minLon, coord[0]);
                                    maxLon = Math.max(maxLon, coord[0]);
                                    minLat = Math.min(minLat, coord[1]);
                                    maxLat = Math.max(maxLat, coord[1]);
                                } else {
                                    console.log(coord);
                                }
                            });
                        });
                    }
                });

                const centerLon = (minLon + maxLon) / 2;
                const centerLat = (minLat + maxLat) / 2;
                console.log(centerLat);
                console.log(centerLon);

                const layout = {
                    title: {
                        text: title,
                        font: { size: 20 },
                        xref: 'paper',
                        x: 0
                    },
                    height: 600,
                    autosize: false,
                    map: {
                        style: 'light',
                        center: { lon: centerLon, lat: centerLat },
                        zoom: 6
                    },
                    margin: { l: 0, r: 0, t: 80, b: 0 },
                    autosize: true
                };

                Plotly.newPlot(mapContainer, [choroplethTrace], layout, { responsive: true });
            }

            
            async function displayMunicipality(countryKey, muniKey, shouldUpdateUrl = true) {
                chartWrapper.style.display = 'block';
                showChartLoader();
                downloadCsvLink.style.display = 'none';

                try {
                    if (shouldUpdateUrl) {
                        updateUrl(countryKey, muniKey);
                    }
                    const countryData = websiteData.countries[countryKey];
                    const muniData = countryData.municipalities[muniKey];
                    const prettyMuniName = muniKey.replace(/_\(.*\)|_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()).trim();
                    const title = `${prettyMuniName}, ${countryData.displayName}`;

                    videoTitle.textContent = `Video: ${title}`;
                    videoPlayer.src = API_BASE_URL + muniData.video;
                    videoContainer.style.display = 'block';

                    const response = await fetch(API_BASE_URL + muniData.csv);
                    if (!response.ok) throw new Error(`Could not fetch ${muniData.csv}`);
                    
                    const csvText = await response.text();
                    Papa.parse(csvText, {
                        header: true, dynamicTyping: true, skipEmptyLines: true,
                        complete: (results) => {
                            const chartData = results.data.filter(d => d.date && d.luminosity !== undefined);
                            if (chartData.length === 0) throw new Error("No valid data found in CSV.");
                            downloadCsvLink.href = API_BASE_URL + muniData.csv;
                            downloadCsvLink.download = `${muniKey}.csv`;
                            downloadCsvLink.style.display = 'inline-block';
                            const countryEvents = countryData.events || [];
                            const muniEvents = muniData.events || [];
                            drawChart(chartData, countryEvents, muniEvents, title);
                        },
                        error: (err) => { throw new Error(`CSV Parsing Error: ${err.message}`); }
                    });
                } catch (error) {
                    console.error("Error displaying municipality:", error);
                    chartContainer.innerHTML = `<div class="error-message">${error.message}</div>`;
                    chartWrapper.style.display = 'block';
                }
            }


            function drawChart(data, countryEvents, muniEvents, title) {
                const dates = data.map(row => row.date);
                const values = data.map(row => row.luminosity);

                const scatterTrace = {
                    x: dates,
                    y: values,
                    mode: 'markers',
                    type: 'scatter',
                    name: 'Data Points',
                    marker: { color: 'grey', opacity: 0.7 }
                };

                const numericDates = dates.map(d => new Date(d).getTime());
                const loessGenerator = science.stats.loess().bandwidth(loess_bandwidth);
                const loessData = loessGenerator(numericDates, values);

                const loessTrace = {
                    x: dates,
                    y: loessData,
                    mode: 'lines',
                    name: `LOESS Fit (${loess_bandwidth})`,
                    line: { color: '#0056b3', width: 3 }
                };

                const shapes = [];
                const annotations = [];

                countryEvents.forEach((event) => {
                    shapes.push({
                        type: 'rect',
                        xref: 'x',
                        yref: 'paper',
                        x0: event.start_date,
                        y0: 0,
                        x1: event.end_date,
                        y1: 1,
                        fillcolor: 'rgba(211, 47, 47, 0.2)',
                        line: { width: 0 }
                    });
                    annotations.push({
                        x: event.start_date,
                        y: 0.1,
                        yref: 'paper',
                        text: `${event.name}`,
                        showarrow: false,
                        xanchor: 'left',
                        textangle: -90,
                        font: { color: '#b71c1c', size: 13 }
                    });
                });

                muniEvents.forEach((event) => {
                    shapes.push({
                        type: 'rect',
                        xref: 'x',
                        yref: 'paper',
                        x0: event.start_date,
                        y0: 0,
                        x1: event.end_date,
                        y1: 1,
                        fillcolor: 'rgba(25, 118, 210, 0.2)',
                        line: { width: 0 }
                    });
                    annotations.push({
                        x: event.start_date,
                        y: 0.1,
                        yref: 'paper',
                        text: `${event.name}`,
                        showarrow: false,
                        xanchor: 'left',
                        textangle: -90,
                        font: { color: '#0d47a1', size: 13 }
                    });
                });

                const allDatesNumeric = numericDates.sort((a, b) => a - b);
                const padding = (allDatesNumeric[allDatesNumeric.length - 1] - allDatesNumeric[0]) * 0.02;
                const minDate = new Date(allDatesNumeric[0] - padding);
                const maxDate = new Date(allDatesNumeric[allDatesNumeric.length - 1] + padding);

                const layout = {
                    title: {
                        text: title,
                        font: { size: 20 },
                        xref: 'paper',
                        x: 0
                    },
                    xaxis: {
                        title: { text: 'Date' },
                        range: [minDate.toISOString().slice(0, 10), maxDate.toISOString().slice(0, 10)],
                    },
                    yaxis: { title: { text: 'Luminosity (nW/sr/cm¬≤)' } },
                    shapes: shapes,
                    annotations: annotations,
                    showlegend: true,
                    legend: { x: 1, xanchor: 'right', y: 1 },
                    margin: { l: 60, r: 20, t: 80, b: 50 },
                    dragmode: 'pan'
                };

                Plotly.newPlot(chartContainer, [scatterTrace, loessTrace], layout, { responsive: true });
                calculateAndDisplayStats(dates, loessData);
            }


            function updateFooter(lastRunDate) {
                const currentYear = new Date().getFullYear();
                mainFooter.innerHTML = `
                    &copy; ${currentYear} All rights reserved. Last run date: ${lastRunDate}.
                    Contact: <a href="mailto:menantlanalysis@gmail.com">menantlanalysis@gmail.com</a>
                `;
            }

            initialize();
        });
    </script>
</body>
</html>