<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Middle East & North Africa Nighttime Lights</title>
   <style>
    body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        margin: 0;
        background-color: #f4f4f9;
        color: #333;
        display: flex; /* Make body a flex container */
        flex-direction: column; /* Stack children vertically */
        min-height: 100vh; /* Ensure body takes full viewport height */
        padding-bottom: 60px; /* Add padding to body to account for fixed footer height */
    }
    #app-container {
        display: flex;
        flex-grow: 1; /* Allows app-container to take up available space */
        overflow: hidden; /* Prevent app-container from creating its own scrollbar */
    }
    #menu {
        width: 300px;
        flex-shrink: 0;
        background-color: #fff;
        border-right: 1px solid #ddd;
        padding: 20px;
        overflow-y: auto; /* Make menu scrollable */
        box-shadow: 2px 0 5px rgba(0,0,0,0.05);
    }
    #menu h2 {
        margin-top: 0;
        color: #0056b3;
    }
    #menu .country-name, #menu .muni-item {
        cursor: pointer;
        padding: 8px;
        border-radius: 4px;
        margin-bottom: 5px;
        transition: background-color 0.2s;
        user-select: none; /* Prevent text selection on click */
    }
    #menu .country-name:hover, #menu .muni-item:hover {
        background-color: #e9ecef;
    }
    /* --- COLLAPSIBLE STYLES --- */
    .country-name::before {
        content: '‚ñ∫ ';
        font-size: 0.8em;
    }
    .country-name.open::before {
        content: '‚ñº ';
    }
    .muni-list {
        list-style-type: none;
        padding-left: 20px;
        border-left: 2px solid #0056b3;
        margin-left: 8px;
        display: none; /* Hidden by default */
    }
    .muni-list.open {
        display: block; /* Shown when open */
    }
    #content {
        flex-grow: 1;
        padding: 20px;
        overflow-y: auto; /* Make content area scrollable */
    }
    #video-container, #chart-wrapper {
        background-color: #fff;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        margin-bottom: 20px;
    }
    #video-player {
        width: 100%;
        height: auto;
        max-height: 70vh;
        border-radius: 4px;
        background-color: #000;
    }
    h3 {
        border-bottom: 2px solid #0056b3;
        padding-bottom: 5px;
        margin-top: 0;
    }
    .loader, .error-message {
        text-align: center;
        padding: 40px;
        font-size: 1.2em;
        color: #666;
    }
    /* --- FOOTER STYLES --- */
    footer {
        background-color: #333;
        color: #fff;
        text-align: center;
        padding: 15px 20px;
        font-size: 0.9em;
        border-top: 1px solid #444;
        position: fixed;
        bottom: 0;
        left: 0;
        width: 100%;
        z-index: 1000;
        height: auto;
    }
    footer a {
        color: #fff;
        text-decoration: none;
    }
    footer a:hover {
        text-decoration: underline;
    }
   </style>
</head>
<body>

    <div id="app-container">
        <nav id="menu">
            <h2>Navigation üó∫Ô∏è</h2>
            <div id="location-list"><div class="loader">Loading Data...</div></div>
        </nav>
        <main id="content">
            <div id="video-container" style="display:none;">
                <h3 id="video-title">Video</h3>
                <video id="video-player" controls autoplay muted playsinline></video>
            </div>
            <div id="chart-wrapper" style="display:none;">
                <h3>Data Chart üìà</h3>
                <div id="chart-container">
                  <div id="chart-loader" class="loader">Loading Chart...</div>
                </div>
            </div>
        </main>
    </div>
    <footer id="main-footer"></footer>

    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/science@1.9.3/science.v1.min.js"></script>

    <script>
        document.addEventListener('DOMContentLoaded', () => {

            const locationList = document.getElementById('location-list');
            const videoContainer = document.getElementById('video-container');
            const videoTitle = document.getElementById('video-title');
            const videoPlayer = document.getElementById('video-player');
            const chartWrapper = document.getElementById('chart-wrapper');
            const chartContainer = document.getElementById('chart-container');
            const chartLoader = document.getElementById('chart-loader');
            const mainFooter = document.getElementById('main-footer');
            
            let websiteData = {};

            async function initialize() {
                try {
                    const [configResponse, eventsResponse] = await Promise.all([
                        fetch('config.json'),
                        fetch('events.json')
                    ]);
                    if (!configResponse.ok || !eventsResponse.ok) {
                       throw new Error('Network response was not ok.');
                    }
                    const configData = await configResponse.json();
                    const eventsData = await eventsResponse.json();

                    for (const countryKey in eventsData) {
                        if (configData.countries[countryKey]) {
                            configData.countries[countryKey].events = eventsData[countryKey].events || [];
                            if (eventsData[countryKey].municipalities) {
                                for (const muniKey in eventsData[countryKey].municipalities) {
                                    if (configData.countries[countryKey].municipalities[muniKey]) {
                                        configData.countries[countryKey].municipalities[muniKey].events = eventsData[countryKey].municipalities[muniKey].events || [];
                                    }
                                }
                            }
                        }
                    }
                    websiteData = configData;
                    buildNavigation(websiteData);
                    handleUrlOnLoad(); // Check URL for initial view
                    updateFooter(websiteData.last_run_date);
                } catch (error) {
                    console.error("Failed to load or process data:", error);
                    locationList.innerHTML = `<div class="error-message">Error: Could not load site data.</div>`;
                }
            }

            function buildNavigation(data) {
                locationList.innerHTML = '';
                for (const countryKey in data.countries) {
                    const country = data.countries[countryKey];
                    const countryDiv = document.createElement('div');
                    const countryNameH3 = document.createElement('h3');
                    countryNameH3.className = 'country-name';
                    countryNameH3.textContent = country.displayName;
                    countryNameH3.dataset.countryKey = countryKey;
                    countryDiv.appendChild(countryNameH3);

                    const muniList = document.createElement('ul');
                    muniList.className = 'muni-list';
                    for (const muniKey in country.municipalities) {
                        const muniItem = document.createElement('li');
                        muniItem.className = 'muni-item';
                        muniItem.textContent = muniKey.replace(/_\(.*\)|_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()).trim();
                        muniItem.dataset.countryKey = countryKey;
                        muniItem.dataset.muniKey = muniKey;
                        muniList.appendChild(muniItem);
                    }
                    countryDiv.appendChild(muniList);
                    locationList.appendChild(countryDiv);
                }
            }
            
            // --- UPDATED CLICK HANDLER FOR COLLAPSIBLE LISTS ---
            locationList.addEventListener('click', (e) => {
                const target = e.target;
                const { countryKey, muniKey } = target.dataset;

                if (target.classList.contains('country-name')) {
                    // It's a country click, toggle sublist and show video
                    target.classList.toggle('open');
                    target.nextElementSibling.classList.toggle('open');
                    displayCountry(countryKey);
                } else if (target.classList.contains('muni-item')) {
                    // It's a municipality click
                    displayMunicipality(countryKey, muniKey);
                }
            });

            // --- URL HANDLING LOGIC ---
            function updateUrl(countryKey, muniKey = null) {
                const viewParam = muniKey ? `${countryKey},${muniKey}` : countryKey;
                const url = new URL(window.location);
                url.searchParams.set('view', viewParam);
                // Use pushState to change URL without reloading
                history.pushState({ view: viewParam }, '', url);
            }

            function handleUrlOnLoad() {
                const params = new URLSearchParams(window.location.search);
                const view = params.get('view');
                if (!view) return;

                const [countryKey, muniKey] = view.split(',');
                
                if (websiteData.countries[countryKey]) {
                    // Expand the country list to show selection
                    const countryHeader = document.querySelector(`.country-name[data-country-key="${countryKey}"]`);
                    if (countryHeader) {
                        countryHeader.classList.add('open');
                        countryHeader.nextElementSibling.classList.add('open');
                    }
                    
                    if (muniKey && websiteData.countries[countryKey].municipalities[muniKey]) {
                        displayMunicipality(countryKey, muniKey, false); // Don't update URL again
                    } else {
                        displayCountry(countryKey, false); // Don't update URL again
                    }
                }
            }

            async function displayCountry(countryKey, shouldUpdateUrl = true) {
                // --- 1. Initial Setup and UI Update ---
                const chartContainer = document.getElementById('chart-container');
                chartContainer.innerHTML = `<div class="loader">Loading Aggregated Chart...</div>`;
                chartWrapper.style.display = 'block';

                if (shouldUpdateUrl) {
                    updateUrl(countryKey);
                }
                
                try {
                    const countryData = websiteData.countries[countryKey];
                    
                    // Display video and basic info
                    videoTitle.textContent = `Video: ${countryData.displayName}`;
                    videoPlayer.src = countryData.video;
                    videoContainer.style.display = 'block';

                    // --- 2. Fetch All Municipality Data Concurrently ---
                    const municipalities = Object.values(countryData.municipalities);
                    const promises = municipalities.map(muni => {
                        return new Promise(async (resolve, reject) => {
                            if (!muni.csv) return resolve([]); // Resolve with empty if no CSV
                            try {
                                const response = await fetch(muni.csv);
                                if (!response.ok) throw new Error(`Failed to fetch ${muni.csv}`);
                                const csvText = await response.text();
                                Papa.parse(csvText, {
                                    header: true,
                                    dynamicTyping: true,
                                    skipEmptyLines: true,
                                    complete: (results) => {
                                        const data = results.data.filter(d => d.date && d.luminosity !== undefined);
                                        // Convert dates to timestamps for easier math
                                        resolve(data.map(d => ({ ...d, time: new Date(d.date).getTime() })));
                                    },
                                    error: (err) => reject(new Error(`Parsing error in ${muni.csv}: ${err.message}`))
                                });
                            } catch (fetchErr) {
                                reject(fetchErr);
                            }
                        });
                    });

                    const allMuniData = await Promise.all(promises);

                    // --- 3. Create Unified Timeline and Interpolate Data ---
                    // Get all unique dates from all datasets and sort them
                    const allDatesSet = new Set(allMuniData.flat().map(d => d.date));
                    const unifiedTimeline = Array.from(allDatesSet).sort().map(date => ({
                        date,
                        time: new Date(date).getTime() 
                    }));

                    const completedMuniData = allMuniData.map(muniData => {
                        if (muniData.length === 0) return [];
                        // Sort individual muni data by time to enable interpolation
                        const sortedData = [...muniData].sort((a, b) => a.time - b.time);

                        return unifiedTimeline.map(({ date, time }) => {
                            const existingPoint = sortedData.find(p => p.time === time);
                            if (existingPoint) return { date, luminosity: existingPoint.luminosity };

                            // Find points before and after the missing date
                            const prevPoint = sortedData.slice().reverse().find(p => p.time < time);
                            const nextPoint = sortedData.find(p => p.time > time);

                            let luminosity;
                            if (prevPoint && nextPoint) {
                                // --- Interpolate: The date is between two points ---
                                const timeDiff = nextPoint.time - prevPoint.time;
                                const valueDiff = nextPoint.luminosity - prevPoint.luminosity;
                                const timeRatio = (time - prevPoint.time) / timeDiff;
                                luminosity = prevPoint.luminosity + (valueDiff * timeRatio);
                            } else if (prevPoint) {
                                // --- Extrapolate: Use nearest point at the end ---
                                luminosity = prevPoint.luminosity;
                            } else if (nextPoint) {
                                // --- Extrapolate: Use nearest point at the beginning ---
                                luminosity = nextPoint.luminosity;
                            } else {
                                luminosity = 0; // Fallback if a muni has no data at all
                            }
                            return { date, luminosity };
                        });
                    });

                    // --- 4. Aggregate the Completed Datasets ---
                    const aggregatedData = {};
                    completedMuniData.forEach(dataSet => {
                        dataSet.forEach(({ date, luminosity }) => {
                            if (!aggregatedData[date]) {
                                aggregatedData[date] = 0;
                            }
                            aggregatedData[date] += luminosity;
                        });
                    });

                    const finalChartData = Object.entries(aggregatedData).map(([date, luminosity]) => ({ date, luminosity }));

                    if (finalChartData.length === 0) {
                        throw new Error("No data available to plot for this country.");
                    }
                    
                    // --- 5. Draw the Chart ---
                    drawChart(finalChartData, countryData.events || [], [], `Aggregated Luminosity in ${countryData.displayName}`);

                } catch (error) {
                    console.error("Error displaying country aggregate:", error);
                    chartContainer.innerHTML = `<div class="error-message">${error.message}</div>`;
                }
            }
            
            async function displayMunicipality(countryKey, muniKey, shouldUpdateUrl = true) {
                try {
                    if (shouldUpdateUrl) {
                        updateUrl(countryKey, muniKey);
                    }
                    const countryData = websiteData.countries[countryKey];
                    const muniData = countryData.municipalities[muniKey];
                    const prettyMuniName = muniKey.replace(/_\(.*\)|_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()).trim();
                    const title = `${prettyMuniName}, ${countryData.displayName}`;

                    videoTitle.textContent = `Video: ${title}`;
                    videoPlayer.src = muniData.video;
                    videoContainer.style.display = 'block';
                    chartWrapper.style.display = 'block';

                    const response = await fetch(muniData.csv);
                    if (!response.ok) throw new Error(`Could not fetch ${muniData.csv}`);
                    
                    const csvText = await response.text();
                    Papa.parse(csvText, {
                        header: true,
                        dynamicTyping: true,
                        skipEmptyLines: true,
                        complete: (results) => {
                            const chartData = results.data.filter(d => d.date && d.luminosity !== undefined);
                            if (chartData.length === 0) throw new Error("No valid data (rows with 'date' and 'luminosity') found in CSV.");
                            
                            const countryEvents = countryData.events || [];
                            const muniEvents = muniData.events || [];
                            drawChart(chartData, countryEvents, muniEvents, title);
                        },
                        error: (err) => { throw new Error(`CSV Parsing Error: ${err.message}`); }
                    });
                    chartLoader.innerHTML = "";
                } catch (error) {
                    console.error("Error displaying municipality:", error);
                    chartContainer.innerHTML = `<div class="error-message">${error.message}</div>`;
                    chartWrapper.style.display = 'block';
                }
            }

            function drawChart(data, countryEvents, muniEvents, title) {
                const dates = data.map(row => row.date);
                const values = data.map(row => row.luminosity);
                
                const scatterTrace = { x: dates, y: values, mode: 'markers', type: 'scatter', name: 'Data Points', marker: { color: 'grey', opacity: 0.7 } };

                const bandwidth = 0.3;
                const numericDates = dates.map(d => new Date(d).getTime());
                const loessGenerator = science.stats.loess().bandwidth(bandwidth);
                const loessData = loessGenerator(numericDates, values);

                const loessTrace = { x: dates, y: loessData, mode: 'lines', name: `LOESS Fit (${bandwidth})`, line: { color: '#0056b3', width: 3 } };
                
                const shapes = [];
                const annotations = [];

                countryEvents.forEach((event) => {
                    shapes.push({ type: 'rect', xref: 'x', yref: 'paper', x0: event.start_date, y0: 0, x1: event.end_date, y1: 1, fillcolor: 'rgba(211, 47, 47, 0.2)', line: { width: 0 } });
                    annotations.push({ x: event.start_date, y: 0.95, yref: 'paper', text: `${event.name}`, showarrow: false, xanchor: 'left', font: { color: '#b71c1c'} });
                });
                muniEvents.forEach((event) => {
                    shapes.push({ type: 'rect', xref: 'x', yref: 'paper', x0: event.start_date, y0: 0, x1: event.end_date, y1: 1, fillcolor: 'rgba(25, 118, 210, 0.2)', line: { width: 0 } });
                     annotations.push({ x: event.start_date, y: 0.90, yref: 'paper', text: `${event.name}`, showarrow: false, xanchor: 'left', font: { color: '#0d47a1'} });
                });
                
                const layout = {
                    title: `Luminosity in ${title}`, xaxis: { title: 'Date' }, yaxis: { title: 'Luminosity' },
                    shapes: shapes, annotations: annotations, showlegend: true, legend: { x: 1, xanchor: 'right', y: 1 },
                    margin: { l: 60, r: 20, t: 50, b: 50 }, height: 500
                };
                Plotly.newPlot(chartContainer, [scatterTrace, loessTrace], layout, {responsive: true});
            }

            function updateFooter(lastRunDate) {
                const currentYear = new Date().getFullYear();
                mainFooter.innerHTML = `
                    &copy; ${currentYear} All rights reserved. Last run date: ${lastRunDate}.
                    Contact: <a href="mailto:menantlanalysis@gmail.com">menantlanalysis@gmail.com</a>
                `;
            }

            initialize();
        });
    </script>
</body>
</html>